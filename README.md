## Day1
-  今天学到了什么？ 
   - 分解提取需求的能力，比如说我们直接去分析react要实现一个页面会经历什么，我们需要一个容器去挂载，我们还需要 render 函数去渲染。只有分析出来这些子需求，我们才能更好的实现主要目标
   - 一步一步渐进式实现，我原来思考问题很容易卡主，我现在算是明白了，我总是从很大的角度去思考一个大需求，想着一下子直接实现，其实应该先做一个简单的「板车」，再做「拖拉机」，再做「汽车」
   - 做完一个功能后思考重构
-  遇到了哪些问题？ 
   - 因为之前手撸过mini vue 目前理解上还是没有遇到明显问题
-  这节课对自己有什么帮助？ 
   - 联想到了mini vue，过程很类似
   - 帮助我或得需求拆分的能力
-  放上你写的代码链接(让你动手) 
   - 代码有，仓库还没建，请参见明天的打卡，哈哈


## Day2
### 实现任务调度器
#### 问题
 DOM 树特别大，导致渲染卡顿
#### 解决思路
把任务拆分为多个小任务分别执行
#### 实现
采用 `requestIdleCallback` 分帧运算


### 实现Fiber

**如何做到每次只渲染几个节点？在下次执行的时候依然从之前的位置开始执行？**
把树转化为链表结构，这个链表结构的节点包含的数据为：

- child（孩子节点）
- sibling（兄弟节点）
- parent（父节点，用于拿到回溯找到当前节点的叔叔节点）

使用深度优先遍历不断地返回下一个节点，我们不用先将整棵树先转化为链表再执行渲染任务，而是当前节点任务执行完后，直接就返回下一个节点的渲染任务。

## Day3
### 统一 提交
因为我们使用的是 requestIdleCallback 这个API 来实现渲染任务调度的，他会有一个问题 ，就是是等待有空余时间的时候才会回调，那么就可能出现一个节点树，渲染到某个层级就挺住了，此时主进程没有时间了，那就等着，用户看到的情况就是渲染一堆，过了一会又渲染一堆。

**如何解决?**
我们可以统一来提交，就是我们在遍历 Fiber 树转链表的时候，我们是直接生成 dom 然后就立马 append 到父级容器了，我们可以到最后阶段才将所有dom添加到容器中。

**怎么做到？**

- 什么时候处理完？
   - 只要 nextWorkOfUnit 没有值的时候说明已经结束了
- 能拿到root就行

实现一个递归方法来将前面创建的Fiber的dom，正确的放到父容器就好了
```typescript
function commitWork(fiber) {
  if (!fiber) {
    return;
  }
  // 处理当前节点
  fiber.parent.dom.append(fiber.dom);
  // 处理子节点
  commitWork(fiber.child);
  // 处理兄弟节点
  commitWork(fiber.sibling);
}
```


### 实现函数组件
vite在解析函数组件的时候是直接把这个函数赋值给了 type 属性
那我们要把这个函数中的dom结构拿出来，并且放到上一级的dom中

1. 要执行函数，拿到dom结构
2. 将拿到的dom放到函数组件的服组件中
   1. 这里需要循环一直往上找，因为可能函数组件套函数组件
3. 然后处理props


## Day4

### 实现事件绑定
这个需求很简单，我们只需要在处理 props 的地方去加判断就行， 如果是 `on` 开头的统一认为是一个事件，然后再当前的 dom 上 addEventListener 即可

```typescript
function updateProps(dom, props) {
  const isProperty = (key) => key !== "children";
  Object.keys(props)
    .filter(isProperty)
    .forEach((name) => {
      // 处理事件
      if (name.startsWith("on")) {
        const eventName = name.toLowerCase().substring(2);
        dom.addEventListener(eventName, props[name]);
      } else if (name === "className") {
        dom.setAttribute("class", props[name]);
      } else {
        dom[name] = props[name];
      }
    });
}
```


### 更新 Props
上面的事件添加为我们更新所有的 props 做了一点铺垫，我们要如何做到更新所有的 props 呢，那肯定是要 **新旧VDOM 对比** ，那我们需要解决三个问题 ：

1. 如何得到新的 DOM 树
2. 如何找到老的节点
3. 如何 diff props

**如何得到新的 DOM 树？**
回忆一下初始化的时候是怎么得到的 DOM 树，是执行 `render` 的时候得到的一个的DOM树，通过给 nextWorkOfUnit 不断地赋值，在每个 Fiber 的 dom 属性上就形成了 DOM 树。那么我们更新的时候想要生成 DOM 树的话可以直接执行 `render` 一样的逻辑，结束后然后把此时的 dom 和 props 保存下来就是当前新的 currentRoot 了。

**如何找到老的节点？**
最简单粗暴的方法当然是直接遍历整个 Fiber 树，然后在节点的 dom 中找到要更新的节点。

但是，这个效率太低了，我改一个属性也得遍历一遍树，这明显太累了。其他办法那肯定是有的。

之前已经在老 root 提交完后将它保存下来了，放到了 currentRoot 中了，那么我们新创建的节点在转化成新链表的时候我们可以顺便添加一个属性 alternate，把这个属性的指针指向老的 Fiber 节点。

首先我们有老的结构的 root （保存在 currentRoot）中的，那我们新的 root 节点在第一步创建的时候可以将 alternate 指向 currentRoot。

下一步到新root的下一个节点的时候，我们需要找到老节点对应的下一个节点，这里老节点的下一个节点我们可以通过 currentRoot 的 child 找到。

中间我们会遇到 sibling ，新的 Fiber 树在创建的时候也会有 sibling 的关系，我们查找老的树的对应节点也去 sibling 属性找就是了。

就这样依次创建，依次将心树的每个节点的 alternate 属性正确的指向，到最后形成的新的 Fiber 树的每一个节点都带着与之对应的老的树的节点，这样下一步就可以为每个节点做 diff 逻辑了。

**如何 diff props**

对比新旧 fiber 对比策略：

1. 新老 fiber 的 type 是否相同，相同就是更新，不同就是创建 
2. 新老 fiber 的 props 是否相同

对比新旧 props 对比策略

1. 老的有新的没有，delete
2. 新的有老的没有，add
3. 老的有新的也有，update


## Day5
### 实现更新的创建和删除
前面实现了更新的编辑，现在我们继续去处理创建和删除的情况。type 类型不一致的时候就需要删除旧的，创建新的。

那么需要被删除的就是当前的oldFiber，我们创建一个变量 deletions 来将所有需要被删除的DOM所在的 Fiber 保存起来，然后统一去删除。

在删除的时候除了使用 `fiber.parent.removeChild(fiber.dom)` 来删除普通DOM以外，还需要考虑到函数组件的删除处理。函数组件自己没有 DOM 那么我们就需要继续往上寻找，跟添加函数组件的逻辑相对应。


### 删除多余的节点
当新的比旧的短的时候，那老的多余的节点都要被删除，前面我们处理的删除是节点一一对应的，现在这种情况应该是身上一种情况的子需求。

处理到最后一步的时候，应该再去检测一下此时的 oldFiber 还存不存在，如果存在的话说明还有后续老节点没有被删除，需要继续去删除，删除方式也很简单，直接将此时的 oldFiber 添加到 deletions 即可。但是不要忘记，需要被删除的还有它的兄弟节点， 所以这里应该是 while 以当前的oldFiber位起点遍历他以及他的所有兄弟节点


### 解决边缘情况
这个边缘情况是这样的有一个变量来控制 DOM 或者组件是否渲染  `show && <bar />` ，这种情况我们之前是没有考虑到的



### 优化更新，减少不必要的计算



## Day6
### 实现useState

- 闭包保持变量
- 变量变化重新再setter里面执行update即可
- 为什么使用[xx, setXX] = useState()，而不是{xx, setXX} = useState()
   - 因为数组有下标取值一一对应很方便，减少很多数据处理的逻辑，但是对象是无序的，解构操作也不能保证完全对应

### 批量执行更新
之前的实现是每次有改变就立马重新执行update，不同的setState的触发都会重新update 这样有很大的浪费，我们可以把所有的setter全部缓存起来，然后最后再统一提交更新
### 提前检测，减少不必要的更新
之前我们不管setState不管值有没有变，都会执行更新，但实际上没有必要的


## Day7
### 实现useEffect
首先分析一下 react 的 useEffect 的使用方式，它是一个函数  主要特性是：副作用函数可以句跟依赖项来决定是否再次执行。有两个参数，**副作用函数 **和 **依赖项；可以返回一个函数来做 cleanup。**

- 副作用函数，组件第一次进入的时候会执行一次，之后根据依赖项来决定是否执行
- 依赖项，可以是一个 any数组，可以是空数组，也可以不传
- 返回值，是一个函数，一般用于cleanup。

首先实现第一步，保存组件中的 effects，让 effect 里面的副作用函数都能执行。

1. 在组件初始化的时候把每个组件的effects全部挂到Fiber节点上
2. 初始化结束后遍历 Fiber 调用所有的 effect 的 副作用函数
3. 收集依赖项，的变化去执行对应的副作用

区分初始化和依赖改变的方式是看 Fiber 节点上是否存在 alternate，如果有的话就肯定是更新而不是初始化。


### 实现 cleanup
在副作用函数被执行的时候来保存，在调用所有的 effect 副作用之前调用。遍历 Fiber 节点 ，拿到当前节点之前的节点（alternate）！

